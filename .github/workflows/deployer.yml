# This is the definitive builder workflow for the PaaS platform.
# It is triggered via API by the Vercel function.

name: PaaS Application Builder

# The on: block defines the trigger. This is the part that was causing the 422 error.
# This configuration allows the workflow to be started by an API call.
on:
  workflow_dispatch:
    inputs:
      owner:
        description: 'The owner of the user repo'
        required: true
      repo:
        description: 'The name of the user repo'
        required: true
      railwayServiceId:
        description: 'The ID of the Railway service to update'
        required: true
      githubRepoId:
        description: 'The unique ID of the GitHub repository'
        required: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
      # Step 1: Check out the user's application code into a subfolder.
      - name: 1. Check out User's Code
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.owner }}/${{ inputs.repo }}
          path: ./user-code

      # Step 2: Run our custom buildpack logic to generate a Dockerfile on the fly.
      - name: 2. Generate Dockerfile with Buildpack
        run: |
          CODE_PATH="./user-code"
          DOCKERFILE_PATH="./user-code/Dockerfile.generated"
          
          # This buildpack currently only supports Node.js.
          if [ -f "$CODE_PATH/package.json" ]; then
            echo "-> Node.js project detected"
            cat <<EOF > $DOCKERFILE_PATH
FROM node:18-alpine
WORKDIR /usr/src/app
COPY package*.json ./
RUN npm install --production
COPY . .
# Railway's default port for Node.js services is 3000.
EXPOSE 3000
CMD ["npm", "start"]
EOF
          else
            echo "-> Error: Unknown project type. No package.json found."
            exit 1
          fi

      # Step 3: Log in to the GitHub Container Registry (GHCR).
      - name: 3. Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Step 4: Build the Docker image from the user's code and our generated Dockerfile,
      # then push it to GHCR. We use the commit SHA for a unique, traceable tag.
      - name: 4. Build and Push Docker Image
        id: build_image
        run: |
          IMAGE_ID=ghcr.io/${{ github.repository_owner }}/${{ inputs.repo }}:${{ github.sha }}
          echo "IMAGE_ID=$IMAGE_ID" >> $GITHUB_OUTPUT
          docker build ./user-code -f ./user-code/Dockerfile.generated -t $IMAGE_ID
          docker push $IMAGE_ID

      # Step 5: Tell Railway to use the new image we just pushed.
      # This step uses Node.js to run a GraphQL client to talk to the Railway API.
      - name: 5. Deploy Image to Railway
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm install graphql graphql-request
      - name: Call Railway API to update service
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
          SERVICE_ID: ${{ inputs.railwayServiceId }}
          IMAGE_NAME: ${{ steps.build_image.outputs.IMAGE_ID }}
        run: |
          node -e '
            const { GraphQLClient, gql } = require("graphql-request");
            const client = new GraphQLClient("https://backboard.railway.app/graphql/v2", {
              headers: { Authorization: `Bearer ${process.env.RAILWAY_API_TOKEN}` },
            });
            const mutation = gql`
              mutation serviceUpdate($serviceId: String!, $imageId: String!) {
                serviceUpdate(id: $serviceId, input: { image: $imageId }) { id }
              }
            `;
            client.request(mutation, { serviceId: process.env.SERVICE_ID, imageId: process.env.IMAGE_NAME })
              .then(data => console.log("✅ Railway deployment successfully triggered:", data))
              .catch(err => { console.error("❌ Failed to trigger Railway deployment:", err); process.exit(1); });
          '